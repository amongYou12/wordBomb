--[[
    UNPATCHABOMB [v999 - FINAL HUMANITY EDITION]
    - SETTINGS: Updated to your exact specifications for max realism.
    - FLEX ENGINE: Now uses BurstSpeed, HesitationAdd, and TypoChance dynamically.
    - LOGIC: No freezing, perfect First Word skipping, God Tier UI.
]]--

local SCRIPT_VERSION = "v999_FinalHumanity"
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")

if not game:IsLoaded() then game.Loaded:Wait() end

--------------------------------------------------------------------------------
-- 1. UTILITIES & CONFIG
--------------------------------------------------------------------------------
local function SafeRandom(min, max)
    if not min then return 0 end
    if not max then return math.random(min) end 
    return math.random(min, max)
end

local function GetRandomTime(tbl)
    return SafeRandom(tbl[1]*1000, tbl[2]*1000) / 1000
end

local function Sanitize(s) 
    return s:gsub("%s+", ""):gsub("[^a-zA-Z0-9%-]", "") 
end

local function ShuffleTable(t)
    for i = #t, 2, -1 do
        local j = SafeRandom(1, i)
        t[i], t[j] = t[j], t[i]
    end
end

--------------------------------------------------------------------------------
-- 2. CORE LOGIC DATA & HUMAN SETTINGS
--------------------------------------------------------------------------------
local vim = game:GetService("VirtualInputManager")
local DictionaryURLs = {
    "https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words_alpha.txt",
    "https://raw.githubusercontent.com/amongYou12/wordBomb/refs/heads/main/enable1.txt"
}
local LL_BLACKLIST_URL = "https://raw.githubusercontent.com/amongYou12/something./refs/heads/main/BlacklistForLastLetter.txt"
local WB_BLACKLIST_URL = "https://raw.githubusercontent.com/amongYou12/something./refs/heads/main/BlacklistForWordbomb.txt"

-- MASTER HUMAN SETTINGS
local TYPING_SETTINGS = {
    BaseSpeed = {0.075, 0.1},
    StartSlowDelay = {0.08, 0.2},
    HesitationChance = 0.32,
    HesitationDelay = {0.15, 0.3},
    SubmitDelay = {0.1, 0.2}         
}

local FLEX_MODIFIERS = {
    BurstChance = 0.15,        
    BurstSpeed = 0.02,         
    TypoChance = 0.20,         
    HesitationAdd = 0.15
}

local LL_Enabled, WB_Enabled = false, false
local LL_Table, WB_Table, ALL_WORDS = {}, {}, {}
local SESSION_BLACKLIST = {} 
local isTyping, lastFound = false, ""
local GlobalEnv = (getgenv and getgenv()) or _G
if not GlobalEnv._UPB_History then GlobalEnv._UPB_History = {} end

local function CheckHist(w) return GlobalEnv._UPB_History[w:lower()] end
local function AddHist(w) GlobalEnv._UPB_History[w:lower()] = true end

local function FetchBlacklist(url, targetTable)
    local s, content = pcall(function() return game:HttpGet(url) end)
    if s then
        content = content:gsub("\n", ",")
        for chunk in content:gmatch("([^,]+)") do
            local clean = Sanitize(chunk):lower()
            if clean ~= "" then targetTable[clean] = true end
        end
        return true
    end
    return false
end

local function IsBlacklisted(w)
    local low = w:lower()
    if SESSION_BLACKLIST[low] then return true end
    if LL_Enabled and LL_Table[low] then return true end
    if WB_Enabled and WB_Table[low] then return true end
    return false
end

local function GetStartingCount(suffix)
    local count = 0; local sufLen = #suffix
    for _, w in ipairs(ALL_WORDS) do
        if w:sub(1, sufLen):lower() == suffix then
            count = count + 1; if count > 10 then return 10 end 
        end
    end
    return count
end

--------------------------------------------------------------------------------
-- 3. UI ENGINE
--------------------------------------------------------------------------------
local Colors = {
    Background = Color3.fromRGB(18, 18, 24),
    Element = Color3.fromRGB(28, 28, 36),
    ElementHover = Color3.fromRGB(38, 38, 46),
    Text = Color3.fromRGB(240, 240, 240),
    SubText = Color3.fromRGB(140, 140, 150),
    Accent = Color3.fromRGB(255, 50, 50) 
}

local UI_ElementsToColor = {} 

local function GetUI_Parent()
    if getgenv and getgenv().gethui then return getgenv().gethui() end
    if CoreGui then return CoreGui end
    return Players.LocalPlayer:WaitForChild("PlayerGui")
end

local ParentTarget = GetUI_Parent()
if ParentTarget:FindFirstChild("Unpatchabomb") then ParentTarget.Unpatchabomb:Destroy() end

local Screen = Instance.new("ScreenGui")
Screen.Name = "Unpatchabomb"
Screen.Parent = ParentTarget
Screen.ResetOnSpawn = false

local function Tween(obj, props, time)
    TweenService:Create(obj, TweenInfo.new(time or 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), props):Play()
end

local function AddRGBStroke(obj, thickness)
    local s = Instance.new("UIStroke")
    s.Parent = obj
    s.Color = Colors.Accent
    s.Thickness = thickness or 1
    s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    table.insert(UI_ElementsToColor, s)
    return s
end

-- MAIN FRAME
local MainFrame = Instance.new("Frame")
MainFrame.Name = "Main"
MainFrame.Parent = Screen
MainFrame.Size = UDim2.new(0, 400, 0, 380)
MainFrame.Position = UDim2.new(0.5, -200, 0.5, -190)
MainFrame.BackgroundColor3 = Colors.Background
MainFrame.BorderSizePixel = 0
Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 10)
AddRGBStroke(MainFrame, 2)

-- DRAG
local dragging, dragInput, dragStart, startPos
MainFrame.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true; dragStart = input.Position; startPos = MainFrame.Position end end)
MainFrame.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then dragInput = input end end)
UserInputService.InputChanged:Connect(function(input) if input == dragInput and dragging then local delta = input.Position - dragStart; MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y) end end)
UserInputService.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end end)

-- HEADER
local Header = Instance.new("Frame"); Header.Parent = MainFrame; Header.Size = UDim2.new(1, 0, 0, 40); Header.BackgroundColor3 = Colors.Element; Header.BorderSizePixel = 0
local HT = Instance.new("TextLabel"); HT.Parent = Header; HT.Size = UDim2.new(1, -20, 1, 0); HT.Position = UDim2.new(0, 15, 0, 0); HT.BackgroundTransparency = 1
HT.Text = "UNPATCHABOMB // v999"; HT.Font = Enum.Font.GothamBlack; HT.TextSize = 16; HT.TextXAlignment = Enum.TextXAlignment.Left; HT.TextColor3 = Colors.Accent
table.insert(UI_ElementsToColor, HT)

-- STATUS
local Status = Instance.new("TextLabel"); Status.Parent = MainFrame; Status.Size = UDim2.new(1, -30, 0, 20); Status.Position = UDim2.new(0, 15, 0, 50); Status.BackgroundTransparency = 1
Status.Text = "Initializing systems..."; Status.Font = Enum.Font.GothamMedium; Status.TextColor3 = Colors.SubText; Status.TextSize = 12; Status.TextXAlignment = Enum.TextXAlignment.Left

-- INPUT
local InputContainer = Instance.new("Frame"); InputContainer.Parent = MainFrame; InputContainer.Size = UDim2.new(1, -30, 0, 40); InputContainer.Position = UDim2.new(0, 15, 0, 80); InputContainer.BackgroundTransparency = 1
local InputBox = Instance.new("TextBox"); InputBox.Parent = InputContainer; InputBox.Size = UDim2.new(0.7, -5, 1, 0); InputBox.BackgroundColor3 = Colors.Element; InputBox.Text = ""; InputBox.PlaceholderText = "Enter substring..."; InputBox.TextColor3 = Colors.Text; InputBox.Font = Enum.Font.GothamBold; InputBox.TextSize = 14
Instance.new("UICorner", InputBox).CornerRadius = UDim.new(0, 6)
local IS = AddRGBStroke(InputBox, 1); IS.Transparency = 0.5
local KillBtn = Instance.new("TextButton"); KillBtn.Parent = InputContainer; KillBtn.Size = UDim2.new(0.3, -5, 1, 0); KillBtn.Position = UDim2.new(0.7, 5, 0, 0); KillBtn.BackgroundColor3 = Colors.Element; KillBtn.Text = "EXECUTE"; KillBtn.TextColor3 = Colors.Accent; KillBtn.Font = Enum.Font.GothamBlack; KillBtn.TextSize = 12
Instance.new("UICorner", KillBtn).CornerRadius = UDim.new(0, 6); local KS = AddRGBStroke(KillBtn, 1); KS.Transparency = 0.5; table.insert(UI_ElementsToColor, KillBtn)

-- INPUT ANIMS
KillBtn.MouseEnter:Connect(function() Tween(KillBtn, {BackgroundColor3 = Colors.ElementHover}) end)
KillBtn.MouseLeave:Connect(function() Tween(KillBtn, {BackgroundColor3 = Colors.Element}) end)
InputBox.Focused:Connect(function() Tween(IS, {Transparency = 0}) end)
InputBox.FocusLost:Connect(function() Tween(IS, {Transparency = 0.5}) end)

-- GRID
local Grid = Instance.new("ScrollingFrame"); Grid.Parent = MainFrame; Grid.Size = UDim2.new(1, -30, 0, 240); Grid.Position = UDim2.new(0, 15, 0, 130); Grid.BackgroundTransparency = 1; Grid.BorderSizePixel = 0; Grid.ScrollBarThickness = 2
local UIGrid = Instance.new("UIGridLayout"); UIGrid.Parent = Grid; UIGrid.CellSize = UDim2.new(0.48, 0, 0, 35); UIGrid.CellPadding = UDim2.new(0.04, 0, 0, 10)

local function CreateToggle(text, callback)
    local Btn = Instance.new("TextButton"); Btn.Parent = Grid; Btn.BackgroundColor3 = Colors.Element; Btn.Text = text; Btn.TextColor3 = Colors.SubText; Btn.Font = Enum.Font.GothamSemibold; Btn.TextSize = 11
    Instance.new("UICorner", Btn).CornerRadius = UDim.new(0, 6)
    local state = false
    Btn.MouseEnter:Connect(function() Tween(Btn, {BackgroundColor3 = Colors.ElementHover}) end)
    Btn.MouseLeave:Connect(function() Tween(Btn, {BackgroundColor3 = Colors.Element}) end)
    Btn.MouseButton1Click:Connect(function()
        state = not state
        callback(state, Btn)
        if state then Tween(Btn, {TextColor3 = Colors.Text}); AddRGBStroke(Btn, 1)
        else Tween(Btn, {TextColor3 = Colors.SubText}); for _, c in pairs(Btn:GetChildren()) do if c:IsA("UIStroke") then c:Destroy() end end end
    end)
    return Btn
end

local function CreateActionBtn(text, color, callback)
    local Btn = Instance.new("TextButton"); Btn.Parent = Grid; Btn.BackgroundColor3 = Colors.Element; Btn.Text = text; Btn.TextColor3 = color or Colors.Text; Btn.Font = Enum.Font.GothamBold; Btn.TextSize = 11
    Instance.new("UICorner", Btn).CornerRadius = UDim.new(0, 6)
    Btn.MouseEnter:Connect(function() Tween(Btn, {BackgroundColor3 = Colors.ElementHover}) end)
    Btn.MouseLeave:Connect(function() Tween(Btn, {BackgroundColor3 = Colors.Element}) end)
    Btn.MouseButton1Click:Connect(callback)
    return Btn
end

-- TOGGLES
local FirstT = CreateToggle("Start With: OFF", function(s, b) b.Text = s and "Start With: ON" or "Start With: OFF" end)
local ShortT = CreateToggle("Short Mode: OFF", function(s, b) b.Text = s and "Short Mode: ON" or "Short Mode: OFF" end)
local TrapT  = CreateToggle("Trap Mode: OFF",  function(s, b) b.Text = s and "Trap Mode: ON" or "Trap Mode: OFF" end)
local FlexT  = CreateToggle("Flex Mode: OFF",  function(s, b) b.Text = s and "Flex Mode: ON" or "Flex Mode: OFF" end)

local LL_T = CreateToggle("Last Letter BL", function(s, b) 
    LL_Enabled = s; if s and next(LL_Table)==nil then Status.Text="Downloading BL..."; FetchBlacklist(LL_BLACKLIST_URL, LL_Table); Status.Text="Ready." end
end)
local WB_T = CreateToggle("Word Bomb BL", function(s, b)
    WB_Enabled = s; if s and next(WB_Table)==nil then Status.Text="Downloading BL..."; FetchBlacklist(WB_BLACKLIST_URL, WB_Table); Status.Text="Ready." end
end)

CreateActionBtn("Clear History", Color3.fromRGB(255, 100, 100), function() GlobalEnv._UPB_History={} Status.Text="History Cleared." end)
CreateActionBtn("Clear Input", Colors.SubText, function() InputBox.Text="" end)
CreateActionBtn("Blacklist Last", Color3.fromRGB(255, 150, 50), function() if lastFound~="" then SESSION_BLACKLIST[lastFound:lower()]=true; Status.Text="Blocked: "..lastFound end end)

-- RGB ENGINE
task.spawn(function()
    local t = 0
    while true do
        t = t + 0.003
        local col = Color3.fromHSV(t % 1, 0.85, 1)
        Colors.Accent = col
        for _, obj in ipairs(UI_ElementsToColor) do
            if obj.Parent then
                if obj:IsA("UIStroke") then Tween(obj, {Color = col}, 0.1)
                elseif obj:IsA("TextLabel") or obj:IsA("TextButton") then Tween(obj, {TextColor3 = col}, 0.1) end
            end
        end
        RunService.Heartbeat:Wait()
    end
end)

--------------------------------------------------------------------------------
-- 4. TYPING ENGINE (HUMANIZED)
--------------------------------------------------------------------------------
local function TypeWord(word, skipCount)
    if not vim then return end 
    isTyping = true
    
    local isFlex = FlexT.Text:find("ON")
    local startDelay = GetRandomTime(TYPING_SETTINGS.StartSlowDelay)
    task.wait(startDelay)
    
    local startIndex = (skipCount or 0) + 1
    
    for i = startIndex, #word do
        local char = word:sub(i,i):upper()
        local code = Enum.KeyCode[char] or (char == "-" and Enum.KeyCode.Minus)
        
        if isFlex then
            -- Typo Logic (Percentage check)
            if i > 2 and i < #word and (SafeRandom(1, 1000) / 1000) <= FLEX_MODIFIERS.TypoChance then
                local wrongChar = string.char(SafeRandom(65, 90)) 
                local wrongCode = Enum.KeyCode[wrongChar]
                if wrongCode then
                    vim:SendKeyEvent(true, wrongCode, false, game)
                    task.wait(SafeRandom(50, 150)/1000)
                    vim:SendKeyEvent(false, wrongCode, false, game)
                    task.wait(SafeRandom(100, 300)/1000) -- Oh shit moment
                    vim:SendKeyEvent(true, Enum.KeyCode.Backspace, false, game)
                    task.wait(0.05)
                    vim:SendKeyEvent(false, Enum.KeyCode.Backspace, false, game)
                end
            end
            
            -- Hesitation Logic (Base + Mod)
            local hesitChance = TYPING_SETTINGS.HesitationChance + FLEX_MODIFIERS.HesitationAdd
            if (SafeRandom(1, 1000) / 1000) <= hesitChance then
                task.wait(GetRandomTime(TYPING_SETTINGS.HesitationDelay))
            end
        else
            -- Normal Hesitation
            if (SafeRandom(1, 1000) / 1000) <= TYPING_SETTINGS.HesitationChance then
                task.wait(GetRandomTime(TYPING_SETTINGS.HesitationDelay))
            end
        end
        
        if code then 
            vim:SendKeyEvent(true, code, false, game)
            if SafeRandom(1,100) > 90 then RunService.Heartbeat:Wait() end 
            vim:SendKeyEvent(false, code, false, game) 
        end
        
        -- Speed Logic
        local delay = GetRandomTime(TYPING_SETTINGS.BaseSpeed)
        if isFlex and (SafeRandom(1, 1000) / 1000) <= FLEX_MODIFIERS.BurstChance then
            delay = FLEX_MODIFIERS.BurstSpeed
        end
        
        task.wait(delay)
    end
    
    task.wait(GetRandomTime(TYPING_SETTINGS.SubmitDelay))
    vim:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.05)
    vim:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
    isTyping = false
end

--------------------------------------------------------------------------------
-- 5. SEARCH ENGINE
--------------------------------------------------------------------------------
local function DoSearch()
    if isTyping then return end
    local query = Sanitize(InputBox.Text):lower()
    if query == "" then return end
    
    Status.Text = "TARGETING..."
    Status.TextColor3 = Colors.Accent
    
    task.spawn(function()
        local candidates = {}
        local isTrap = TrapT.Text:find("ON")
        local isFirst = FirstT.Text:find("ON")
        local isShort = ShortT.Text:find("ON")
        
        local batch = 0
        for _, v in ipairs(ALL_WORDS) do
            batch = batch + 1
            if batch % 2000 == 0 then RunService.Heartbeat:Wait() end 
            
            local w = Sanitize(v)
            local wLow = w:lower()
            if #w >= 3 and not CheckHist(w) and not IsBlacklisted(w) then
                local match = false
                if isFirst then 
                    if wLow:sub(1, #query) == query then match = true end
                else 
                    if wLow:find(query, 1, true) then match = true end 
                end
                if match then table.insert(candidates, w) end
            end
        end
        
        local found = nil
        if #candidates > 0 then
            ShuffleTable(candidates)
            if isShort then
                local minLen = 999
                for _, w in ipairs(candidates) do
                    if #w < minLen then minLen = #w; found = w end
                end
            elseif isTrap then
                local bestScore = -9999; local limit = 300; local c = 0
                for _, w in ipairs(candidates) do
                    c=c+1; if c>limit then break end
                    if c%30==0 then RunService.Heartbeat:Wait() end
                    local score = 0; local last = w:sub(-1):lower()
                    if string.find("jqxz", last) then score=score+50 end
                    score=score+#w
                    local replies = GetStartingCount(w:sub(-2):lower())
                    if replies==0 then score=score+1000
                    elseif replies<5 then score=score+100
                    else score=score-replies end
                    if score>bestScore then bestScore=score; found=w end
                end
            else
                found = candidates[1]
            end
            if not found then found = candidates[1] end
        end
        
        if found then
            lastFound = found
            AddHist(found)
            Status.Text = "KILL: " .. found:upper()
            Status.TextColor3 = Colors.Accent
            local skipAmt = 0
            if isFirst then skipAmt = #query end
            TypeWord(found, skipAmt)
        else
            Status.Text = "NO MATCH."
            Status.TextColor3 = Color3.fromRGB(255, 50, 50)
        end
    end)
end

-- LOAD
task.spawn(function()
    local c = 0
    for _, url in ipairs(DictionaryURLs) do
        local s, res = pcall(function() return game:HttpGet(url) end)
        if s then for line in res:gmatch("[^\r\n]+") do table.insert(ALL_WORDS, line); c=c+1 end end
    end
    Status.Text = "ARMED: " .. c .. " WORDS"
end)

KillBtn.MouseButton1Click:Connect(DoSearch)
InputBox.FocusLost:Connect(function(e) if e then DoSearch() end end)
