--[[
    UNPATCHABOMB [ULTIMATE EDITION]
    - SOURCE: Multi-Dictionary Support.
    - MODES: Flex (Longest), Short (Shortest), Lock In (Fastest).
    - LOGIC: Mutually exclusive modes & smart history.
]]--

--------------------------------------------------------------------------------
-- 0. CONFIGURATION
--------------------------------------------------------------------------------
local DictionaryURLs = {
    --"https://raw.githubusercontent.com/amongYou12/wordBomb/refs/heads/main/CollinsScrabble", -- Link 1
    "https://raw.githubusercontent.com/amongYou12/wordBomb/refs/heads/main/enable1.txt",
    "https://gist.githubusercontent.com/letterpressfan/4145939/raw/4ca79142f49ce9ac8758cf3146ce14aa89b217cd/in-lp1.1-but-not-csw12.txt",
    "https://raw.githubusercontent.com/gangulwar/JKLM-Bomb-Party-BOT/refs/heads/main/dictionary.txt",
    "https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words_alpha.txt"-- Link 2 (Replace this with your 2nd url)
}

-- The bot will NEVER type words shorter than this, even in "Short Mode".
local MIN_WORD_LENGTH = 10 

local TYPING_SETTINGS = {
    StartSlowDelay = {0.085, 0.095}, 
    BaseSpeed = {0.065, 0.07}, 
    HesitationChance = 0.45,
    HesitationDelay = {0.055, 0.065}, 
    SubmitDelay = {0.05, 0.1}, 
    TypoChance = 0.35, 
    BackspaceSpeed = {0.05, 0.065} 
}


--------------------------------------------------------------------------------
-- 1. GLOBAL HISTORY & VARS
--------------------------------------------------------------------------------
local GlobalEnv = (getgenv and getgenv()) or _G
if not GlobalEnv._Unpatchabomb_History_Final then GlobalEnv._Unpatchabomb_History_Final = {} end

local function CheckHistory(word) return GlobalEnv._Unpatchabomb_History_Final[word:lower()] end
local function AddToHistory(word) GlobalEnv._Unpatchabomb_History_Final[word:lower()] = true end
local function ClearHistory() GlobalEnv._Unpatchabomb_History_Final = {} end

local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local ParentTarget = (gethui and gethui()) or CoreGui:FindFirstChild("RobloxGui") or CoreGui

if ParentTarget:FindFirstChild("Unpatchabomb") then ParentTarget.Unpatchabomb:Destroy() end

--------------------------------------------------------------------------------
-- 2. SMART LOADER
--------------------------------------------------------------------------------
local ALL_WORDS = {}

local function LoadRemoteWords()
    ALL_WORDS = {}
    local seenWords = {} 
    local count = 0
    
    for _, url in ipairs(DictionaryURLs) do
        if url:find("http") then
            local success, content = pcall(function() return game:HttpGet(url) end)
            if success then
                for line in content:gmatch("[^\r\n]+") do
                    local cleanLine = line:match("^%s*(.-)%s*$")
                    if cleanLine and #cleanLine >= MIN_WORD_LENGTH and not seenWords[cleanLine] then
                        seenWords[cleanLine] = true
                        table.insert(ALL_WORDS, cleanLine)
                        count = count + 1
                    end
                end
            else
                warn("Unpatchabomb: Failed to load URL: " .. url)
            end
        end
    end
    seenWords = nil 
    return count
end

--------------------------------------------------------------------------------
-- 3. UI CONSTRUCTION
--------------------------------------------------------------------------------
local Unpatchabomb = Instance.new("ScreenGui"); Unpatchabomb.Name = "Unpatchabomb"; Unpatchabomb.Parent = ParentTarget; Unpatchabomb.ResetOnSpawn = false
local MainFrame = Instance.new("Frame"); MainFrame.Name = "MainFrame"; MainFrame.Parent = Unpatchabomb; MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25); MainFrame.Position = UDim2.new(0.5, -160, 0.5, -100); MainFrame.Size = UDim2.new(0, 320, 0, 160); MainFrame.BorderSizePixel = 0
local MainCorner = Instance.new("UICorner"); MainCorner.CornerRadius = UDim.new(0, 8); MainCorner.Parent = MainFrame
local MainStroke = Instance.new("UIStroke"); MainStroke.Parent = MainFrame; MainStroke.Color = Color3.fromRGB(60, 60, 60); MainStroke.Thickness = 1; MainStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

local TopBar = Instance.new("Frame"); TopBar.Name = "TopBar"; TopBar.Parent = MainFrame; TopBar.BackgroundColor3 = Color3.fromRGB(35, 35, 35); TopBar.Size = UDim2.new(1, 0, 0, 32); TopBar.BorderSizePixel = 0
local TopBarCorner = Instance.new("UICorner"); TopBarCorner.CornerRadius = UDim.new(0, 8); TopBarCorner.Parent = TopBar
local Title = Instance.new("TextLabel"); Title.Parent = TopBar; Title.BackgroundTransparency = 1; Title.Position = UDim2.new(0, 12, 0, 0); Title.Size = UDim2.new(0.5, 0, 1, 0); Title.Font = Enum.Font.GothamBold; Title.Text = "UNPATCHABOMB"; Title.TextColor3 = Color3.fromRGB(255, 255, 255); Title.TextSize = 14; Title.TextXAlignment = Enum.TextXAlignment.Left

local wordCount = LoadRemoteWords()
local WordText = Instance.new("TextLabel"); WordText.Name = "Status"; WordText.Parent = MainFrame; WordText.BackgroundTransparency = 1; WordText.Position = UDim2.new(0, 0, 0.25, 0); WordText.Size = UDim2.new(1, 0, 0.15, 0); WordText.Font = Enum.Font.GothamMedium; WordText.Text = (wordCount > 0 and "Loaded " .. wordCount .. " Words") or "Error/No Words!"; WordText.TextColor3 = Color3.fromRGB(150, 150, 150); WordText.TextSize = 14

local LetterBox = Instance.new("TextBox"); LetterBox.Name = "Input"; LetterBox.Parent = MainFrame; LetterBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40); LetterBox.Position = UDim2.new(0.05, 0, 0.45, 0); LetterBox.Size = UDim2.new(0.65, 0, 0.25, 0); LetterBox.Font = Enum.Font.GothamBold; LetterBox.PlaceholderText = "Type letters..."; LetterBox.Text = ""; LetterBox.TextColor3 = Color3.fromRGB(255, 255, 255); LetterBox.TextSize = 16
local BoxCorner = Instance.new("UICorner"); BoxCorner.Parent = LetterBox
local BoxStroke = Instance.new("UIStroke"); BoxStroke.Parent = LetterBox; BoxStroke.Color = Color3.fromRGB(60, 60, 60)

local RerunButton = Instance.new("TextButton"); RerunButton.Name = "Run"; RerunButton.Parent = MainFrame; RerunButton.BackgroundColor3 = Color3.fromRGB(46, 204, 113); RerunButton.Position = UDim2.new(0.73, 0, 0.45, 0); RerunButton.Size = UDim2.new(0.22, 0, 0.25, 0); RerunButton.Font = Enum.Font.GothamBold; RerunButton.Text = "â–¶"; RerunButton.TextColor3 = Color3.fromRGB(25, 25, 25); RerunButton.TextSize = 18
local RunCorner = Instance.new("UICorner"); RunCorner.Parent = RerunButton

-- BOTTOM BUTTONS ROW (Reset | Short | Flex | Lock)
local function CreateBtn(name, text, pos, color)
    local btn = Instance.new("TextButton"); btn.Name = name; btn.Parent = MainFrame
    btn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    btn.Position = pos
    btn.Size = UDim2.new(0.21, 0, 0.16, 0)
    btn.Font = Enum.Font.GothamBold
    btn.Text = text
    btn.TextColor3 = color
    btn.TextSize = 11
    local c = Instance.new("UICorner"); c.CornerRadius = UDim.new(0, 6); c.Parent = btn
    return btn
end

-- 0.03 gap start + (0.21 width + 0.04 gap)
local ResetButton = CreateBtn("Reset", "Reset", UDim2.new(0.03, 0, 0.76, 0), Color3.fromRGB(231, 76, 60))
local ShortButton = CreateBtn("Short", "Short: OFF", UDim2.new(0.27, 0, 0.76, 0), Color3.fromRGB(150, 150, 150))
local FlexButton  = CreateBtn("Flex", "Flex: OFF", UDim2.new(0.51, 0, 0.76, 0), Color3.fromRGB(150, 150, 150))
local LockInButton= CreateBtn("Lock", "Lock: OFF", UDim2.new(0.75, 0, 0.76, 0), Color3.fromRGB(150, 150, 150))

local MinimizeButton = Instance.new("TextButton"); MinimizeButton.Name = "Minimize"; MinimizeButton.Parent = TopBar; MinimizeButton.BackgroundTransparency = 1; MinimizeButton.Position = UDim2.new(1, -32, 0, 0); MinimizeButton.Size = UDim2.new(0, 32, 1, 0); MinimizeButton.Font = Enum.Font.GothamBold; MinimizeButton.Text = "-"; MinimizeButton.TextColor3 = Color3.fromRGB(200, 200, 200); MinimizeButton.TextSize = 20

-- Dragging
local dragging, dragInput, dragStart, startPos
TopBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true; dragStart = input.Position; startPos = MainFrame.Position
        input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false end end)
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

--------------------------------------------------------------------------------
-- 4. LOGIC ENGINE
--------------------------------------------------------------------------------
local isTyping = false 
local isFlexMode = false -- Longest
local isShortMode = false -- Shortest
local isLockInMode = false -- Speed
local LOCK_IN_MODIFIER = 0.015 

local function SanitizeWord(str)
    if not str then return "" end
    return str:gsub("[^a-zA-Z0-9%-]", "")
end

local function GetRandomTime(timeTable)
    local minVal = timeTable[1]; local maxVal = timeTable[2]
    local minInt = math.floor(minVal * 10000); local maxInt = math.floor(maxVal * 10000)
    local val = math.random(minInt, maxInt) / 10000
    
    if isLockInMode then
        val = val - LOCK_IN_MODIFIER
        if val < 0.005 then val = 0.005 end
    end
    
    return val
end

local function IDA_autoType(rawWord)
    local word = SanitizeWord(rawWord)
    if not word or word == "" or isTyping then return end
    isTyping = true
    
    local vim = game:GetService("VirtualInputManager")
    local function press(key)
        pcall(function()
            vim:SendKeyEvent(true, key, false, game)
            task.wait(0.015) 
            vim:SendKeyEvent(false, key, false, game)
        end)
    end

    for i = 1, #word do
        -- Typo Logic
        if #word > 7 and i == 4 and math.random() < TYPING_SETTINGS.TypoChance then
            task.wait(GetRandomTime(TYPING_SETTINGS.BaseSpeed)) 
            press(Enum.KeyCode.Q)
            task.wait(GetRandomTime(TYPING_SETTINGS.BaseSpeed)) 
            press(Enum.KeyCode.Backspace)
            task.wait(GetRandomTime(TYPING_SETTINGS.BackspaceSpeed))
        end

        local char = word:sub(i, i):upper()
        local code = Enum.KeyCode[char] or (char == " " and Enum.KeyCode.Space)
        if char == "-" then code = Enum.KeyCode.Minus end
        if code then press(code) end

        local delay = (i <= 4) and GetRandomTime(TYPING_SETTINGS.StartSlowDelay) or GetRandomTime(TYPING_SETTINGS.BaseSpeed)
        if math.random() < TYPING_SETTINGS.HesitationChance then delay = delay + GetRandomTime(TYPING_SETTINGS.HesitationDelay) end
        task.wait(delay)
    end

    task.wait(math.max(0.1, GetRandomTime(TYPING_SETTINGS.SubmitDelay)))
    vim:SendKeyEvent(true, Enum.KeyCode.Return, false, game); task.wait(0.1); vim:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
    
    isTyping = false
    WordText.Text = "Waiting..."
    WordText.TextColor3 = Color3.fromRGB(150, 150, 150)
end

local function IDA_PerformSearch()
    if isTyping then return end
    local input = SanitizeWord(LetterBox.Text):lower()
    if input == "" then return end
    
    local statusMsg = "Searching..."
    if isFlexMode then statusMsg = "Scanning (Longest)..." end
    if isShortMode then statusMsg = "Scanning (Shortest)..." end
    WordText.Text = statusMsg
    WordText.TextColor3 = Color3.fromRGB(255, 255, 0)
    
    local found = nil
    
    if isFlexMode then
        -- 1. LONGEST WORD
        local bestWord = ""
        for _, v in ipairs(ALL_WORDS) do
            if v:lower():find(input, 1, true) then
                local cleanV = SanitizeWord(v)
                if not CheckHistory(cleanV) then
                    if #cleanV > #bestWord then bestWord = cleanV end
                end
            end
        end
        if bestWord ~= "" then found = bestWord end

    elseif isShortMode then
        -- 2. SHORTEST WORD
        local bestWord = nil
        local minLen = 999
        for _, v in ipairs(ALL_WORDS) do
            if v:lower():find(input, 1, true) then
                local cleanV = SanitizeWord(v)
                if not CheckHistory(cleanV) then
                    if #cleanV < minLen then
                        bestWord = cleanV
                        minLen = #cleanV
                    end
                end
            end
        end
        if bestWord then found = bestWord end

    else
        -- 3. NORMAL (FIRST MATCH)
        for _, v in ipairs(ALL_WORDS) do
            if v:lower():find(input, 1, true) then
                local cleanV = SanitizeWord(v)
                if not CheckHistory(cleanV) then
                    found = cleanV
                    break
                end
            end
        end
    end

    if found then
        WordText.Text = "Typing: " .. found
        WordText.TextColor3 = isLockInMode and Color3.fromRGB(255, 0, 255) or Color3.fromRGB(0, 200, 255)
        AddToHistory(found)
        IDA_autoType(found)
    else
        WordText.Text = "No Word Found"
        WordText.TextColor3 = Color3.fromRGB(255, 100, 100)
    end
end

--------------------------------------------------------------------------------
-- 5. CONNECTIONS
--------------------------------------------------------------------------------
LetterBox.FocusLost:Connect(function(e) if e then IDA_PerformSearch() end end)
RerunButton.MouseButton1Click:Connect(IDA_PerformSearch)

ResetButton.MouseButton1Click:Connect(function() 
    if isTyping then return end
    ClearHistory() 
    WordText.Text = "History Cleared"
    WordText.TextColor3 = Color3.fromRGB(255, 150, 150)
    task.wait(1)
    WordText.TextColor3 = Color3.fromRGB(150, 150, 150)
    WordText.Text = "Loaded " .. #ALL_WORDS .. " Words"
end)

-- UPDATE VISUALS HELPER
local function UpdateModes()
    -- Update Flex Button
    if isFlexMode then
        FlexButton.Text = "Flex: ON"
        FlexButton.TextColor3 = Color3.fromRGB(46, 204, 113) -- Green
    else
        FlexButton.Text = "Flex: OFF"
        FlexButton.TextColor3 = Color3.fromRGB(150, 150, 150)
    end

    -- Update Short Button
    if isShortMode then
        ShortButton.Text = "Short: ON"
        ShortButton.TextColor3 = Color3.fromRGB(241, 196, 15) -- Yellow
    else
        ShortButton.Text = "Short: OFF"
        ShortButton.TextColor3 = Color3.fromRGB(150, 150, 150)
    end
end

FlexButton.MouseButton1Click:Connect(function()
    isFlexMode = not isFlexMode
    if isFlexMode then isShortMode = false end -- Disable Short if Flex is on
    UpdateModes()
end)

ShortButton.MouseButton1Click:Connect(function()
    isShortMode = not isShortMode
    if isShortMode then isFlexMode = false end -- Disable Flex if Short is on
    UpdateModes()
end)

LockInButton.MouseButton1Click:Connect(function()
    isLockInMode = not isLockInMode
    if isLockInMode then
        LockInButton.Text = "Lock: ON"
        LockInButton.TextColor3 = Color3.fromRGB(52, 152, 219) -- Blue
    else
        LockInButton.Text = "Lock: OFF"
        LockInButton.TextColor3 = Color3.fromRGB(150, 150, 150)
    end
end)

MinimizeButton.MouseButton1Click:Connect(function()
    local isVis = MainFrame.Visible
    MainFrame.Visible = not isVis
    MinimizeButton.Text = isVis and "+" or "-"
end)
