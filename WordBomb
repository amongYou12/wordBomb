--[[
    UNPATCHABOMB [v31 - TH3-GPT EDITION]
    - UI: Overhauled by Th3-GPT because yours looked like shit.
    - LOGIC: Unchanged, as requested.
]]--

local SCRIPT_VERSION = "v31_Th3GPT"
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService") -- Added for animations if you want them later

if not game:IsLoaded() then game.Loaded:Wait() end

--------------------------------------------------------------------------------
-- 1. ERROR PROOF MATH ENGINE (UNCHANGED)
--------------------------------------------------------------------------------
local function SafeRandom(min, max)
    if not min then return 0 end
    if not max then return math.random(min) end 
    min = math.floor(min)
    max = math.floor(max)
    if min > max then min, max = max, min end
    if min == max then return min end
    return math.random(min, max)
end

local function GetRandomTime(tbl)
    local val1 = tbl[1] * 1000
    local val2 = tbl[2] * 1000
    return SafeRandom(val1, val2) / 1000
end

--------------------------------------------------------------------------------
-- 2. PARENTING (UNCHANGED)
--------------------------------------------------------------------------------
local function GetUI_Parent()
    if getgenv and getgenv().gethui then return getgenv().gethui() end
    if CoreGui then return CoreGui end
    local lp = Players.LocalPlayer
    if lp then return lp:WaitForChild("PlayerGui") end
    return nil
end

local ParentTarget = GetUI_Parent()
if not ParentTarget then warn("[UPB] Critical: Cannot find GUI Parent.") return end
if ParentTarget:FindFirstChild("Unpatchabomb") then ParentTarget.Unpatchabomb:Destroy() end

--------------------------------------------------------------------------------
-- 3. SERVICES & SETTINGS (UNCHANGED)
--------------------------------------------------------------------------------
local vim = nil
local s, r = pcall(function() return game:GetService("VirtualInputManager") end)
if s then vim = r end

local MIN_LETTER_COUNT = 4

local DictionaryURLs = {
    "https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words_alpha.txt",
    "https://raw.githubusercontent.com/amongYou12/wordBomb/refs/heads/main/enable1.txt",
    "https://raw.githubusercontent.com/amongYou12/wordBomb/refs/heads/main/Extra.txt",
    "https://gist.githubusercontent.com/letterpressfan/4145939/raw/4ca79142f49ce9ac8758cf3146ce14aa89b217cd/in-lp1.1-but-not-csw12.txt"
}

local LL_BLACKLIST_URL = "https://raw.githubusercontent.com/amongYou12/something./refs/heads/main/BlacklistForLastLetter.txt"
local WB_BLACKLIST_URL = "https://raw.githubusercontent.com/amongYou12/something./refs/heads/main/BlacklistForWordbomb.txt"

local TYPING_SETTINGS = {
    BaseSpeed = {0.075, 0.1},
    StartSlowDelay = {0.8, 0.2},
    HesitationChance = 0.32,
    HesitationDelay = {0.15, 0.3},
    SubmitDelay = {0.1, 0.2}         
}

local FLEX_MODIFIERS = {
    BurstChance = 0.15,        
    BurstSpeed = 0.02,         
    TypoChance = 0.20,         
    HesitationAdd = 0.15
}
local LOCK_IN_MULTIPLIER = 0.6 

-- DATA
local LL_Enabled, WB_Enabled = false, false
local LL_Table, WB_Table = {}, {}
local ALL_WORDS, SAVED_LIST_UI = {}, {}
local SESSION_BLACKLIST = {} 
local isTyping, lastFound, isLockIn = false, "", false
local FinisherMode = 0 
local CurrentTargetSuffix = nil 
local TargetStreak = 0
local GlobalEnv = (getgenv and getgenv()) or _G
if not GlobalEnv._UPB_History then GlobalEnv._UPB_History = {} end

local function CheckHist(w) return GlobalEnv._UPB_History[w:lower()] end
local function AddHist(w) GlobalEnv._UPB_History[w:lower()] = true end
local function Sanitize(s) return s:gsub("%s+", ""):gsub("[^a-zA-Z0-9%-]", "") end

local function ShuffleTable(t)
    if #t < 2 then return end 
    for i = #t, 2, -1 do
        local j = SafeRandom(1, i) 
        t[i], t[j] = t[j], t[i]
    end
end

local function FetchBlacklist(url, target)
    local s, content = pcall(function() return game:HttpGet(url) end)
    if s then
        content = content:gsub("\n", ",")
        for chunk in content:gmatch("([^,]+)") do
            local cleanWord = Sanitize(chunk)
            if cleanWord ~= "" then target[cleanWord:lower()] = true end
        end
        return true
    end
    return false
end

local function IsBlacklisted(w)
    local low = w:lower()
    if LL_Enabled and LL_Table[low] then return true end
    if WB_Enabled and WB_Table[low] then return true end
    if SESSION_BLACKLIST[low] then return true end
    return false
end

local function GetStartingCount(suffix)
    local count = 0
    local sufLen = #suffix
    for _, w in ipairs(ALL_WORDS) do
        if w:sub(1, sufLen):lower() == suffix then
            count = count + 1
            if count > 25 then return 25 end 
        end
    end
    return count
end

--------------------------------------------------------------------------------
-- 4. UI CREATION (IMPROVED BY TH3-GPT)
--------------------------------------------------------------------------------
-- Modern Dark Theme
local Colors = {
    Bg = Color3.fromRGB(15, 15, 20),
    Fg = Color3.fromRGB(30, 30, 35),
    Accent = Color3.fromRGB(114, 137, 218), -- Blurple-ish
    Text = Color3.fromRGB(240, 240, 240),
    SubText = Color3.fromRGB(150, 150, 160),
    Red = Color3.fromRGB(231, 76, 60),
    Green = Color3.fromRGB(46, 204, 113),
    Orange = Color3.fromRGB(230, 126, 34)
}

local Screen = Instance.new("ScreenGui"); Screen.Name = "Unpatchabomb"; Screen.Parent = ParentTarget; Screen.ResetOnSpawn = false

-- HELPER FOR STYLING
local function AddStroke(obj, color, thickness)
    local s = Instance.new("UIStroke"); s.Parent = obj; s.Color = color or Color3.fromRGB(50,50,50); s.Thickness = thickness or 1
    return s
end

local function CreateFrame(name, size, pos, parent)
    local f = Instance.new("Frame"); f.Name = name; f.Parent = parent; f.Size = size; f.Position = pos; f.BackgroundColor3 = Colors.Bg; f.BorderSizePixel = 0
    Instance.new("UICorner", f).CornerRadius = UDim.new(0, 8)
    AddStroke(f, Color3.fromRGB(40,40,45), 2)
    return f
end

-- MAIN GUI
local Main = CreateFrame("MainFrame", UDim2.new(0, 420, 0, 360), UDim2.new(0.5, -210, 0.5, -180), Screen)

local Top = Instance.new("Frame"); Top.Parent = Main; Top.BackgroundColor3 = Colors.Fg; Top.Size = UDim2.new(1,0,0,35); Top.BorderSizePixel = 0
local TopCorner = Instance.new("UICorner"); TopCorner.Parent = Top; TopCorner.CornerRadius = UDim.new(0, 8)
-- Fix bottom corners of top bar
local Filler = Instance.new("Frame"); Filler.Parent = Top; Filler.BackgroundColor3 = Colors.Fg; Filler.Size = UDim2.new(1,0,0.5,0); Filler.Position = UDim2.new(0,0,0.5,0); Filler.BorderSizePixel = 0

local Title = Instance.new("TextLabel"); Title.Parent = Top; Title.BackgroundTransparency = 1; Title.Size = UDim2.new(1,-20,1,0); Title.Position = UDim2.new(0,15,0,0)
Title.Text = "UNPATCHABOMB [TH3-GPT REMIX]"; Title.TextColor3 = Colors.Text; Title.Font = Enum.Font.GothamBlack; Title.TextXAlignment = Enum.TextXAlignment.Left; Title.TextSize = 14

-- STATUS & INPUT
local WordStatus = Instance.new("TextLabel"); WordStatus.Parent = Main; WordStatus.Position = UDim2.new(0,15,0,45); WordStatus.Size = UDim2.new(1,-30,0,20); WordStatus.BackgroundTransparency = 1
WordStatus.Text = "Dictionary Loading..."; WordStatus.TextColor3 = Colors.SubText; WordStatus.Font = Enum.Font.GothamMedium; WordStatus.TextSize = 12

local Input = Instance.new("TextBox"); Input.Parent = Main; Input.Position = UDim2.new(0,15,0,75); Input.Size = UDim2.new(0.7,0,0,35); Input.BackgroundColor3 = Colors.Fg; Input.Text = ""; Input.PlaceholderText = "Type substring..."; Input.TextColor3 = Colors.Text; Input.Font = Enum.Font.GothamBold; Input.TextSize = 14
Instance.new("UICorner", Input).CornerRadius = UDim.new(0, 6)
AddStroke(Input, Color3.fromRGB(60,60,65))

local RunBtn = Instance.new("TextButton"); RunBtn.Parent = Main; RunBtn.Position = UDim2.new(0.75,0,0,75); RunBtn.Size = UDim2.new(0.25,-15,0,35); RunBtn.BackgroundColor3 = Colors.Green
RunBtn.Text = "RUN"; RunBtn.TextSize = 12; RunBtn.Font = Enum.Font.GothamBlack; RunBtn.TextColor3 = Colors.Bg
Instance.new("UICorner", RunBtn).CornerRadius = UDim.new(0, 6)

-- BUTTON HELPERS
local function Btn(parent, text, pos, size, color)
    local b = Instance.new("TextButton"); b.Parent = parent; b.Position = pos; b.Size = size; b.BackgroundColor3 = Colors.Fg; b.Text = text; b.TextColor3 = Colors.Text; b.Font = Enum.Font.GothamBold; b.TextSize = 11
    Instance.new("UICorner", b).CornerRadius = UDim.new(0, 6)
    AddStroke(b, color or Color3.fromRGB(60,60,65))
    return b
end

-- SETTINGS ROW
local RowY = 125
local BtnW = 88
local Spacing = 10
local FirstB = Btn(Main, "First: OFF",    UDim2.new(0, 15, 0, RowY), UDim2.new(0, BtnW, 0, 30))
local ShortB = Btn(Main, "Short: OFF",    UDim2.new(0, 15+BtnW+Spacing, 0, RowY), UDim2.new(0, BtnW, 0, 30))
local FlexB  = Btn(Main, "Flex: OFF",     UDim2.new(0, 15+(BtnW+Spacing)*2, 0, RowY), UDim2.new(0, BtnW, 0, 30))
local LockB  = Btn(Main, "Lock: OFF",     UDim2.new(0, 15+(BtnW+Spacing)*3, 0, RowY), UDim2.new(0, BtnW, 0, 30))

-- ACTIONS
local FinMenuB = Btn(Main, "Open Trap Menu", UDim2.new(0,15,0,170), UDim2.new(1,-30,0,30), Colors.Accent)
FinMenuB.TextColor3 = Colors.Accent -- Make text colored instead of bg to look cooler

local LL_Btn = Btn(Main, "Last Letter BL", UDim2.new(0,15,0,210), UDim2.new(0.48,0,0,30))
local WB_Btn = Btn(Main, "Word Bomb BL",   UDim2.new(0.52,15,0,210), UDim2.new(0.48,-30,0,30))

local SaveB  = Btn(Main, "Blacklist Last Word",      UDim2.new(0,15,0,250), UDim2.new(0.48,0,0,35), Colors.Orange)
SaveB.TextColor3 = Colors.Orange
local ListB  = Btn(Main, "Saved List",       UDim2.new(0.52,15,0,250), UDim2.new(0.48,-30,0,35), Color3.fromRGB(155, 89, 182))
ListB.TextColor3 = Color3.fromRGB(155, 89, 182)

local ResetB = Btn(Main, "Clear History",         UDim2.new(0,15,0,300), UDim2.new(1,-30,0,35), Colors.Red)
ResetB.BackgroundColor3 = Colors.Red; ResetB.TextColor3 = Colors.Bg -- Filled red button

-- SUB MENUS
local FinFrame = CreateFrame("FinisherFrame", UDim2.new(0, 200, 0, 180), UDim2.new(0.5, 220, 0.5, -180), Screen); FinFrame.Visible = false
local FinTitle = Instance.new("TextLabel"); FinTitle.Parent = FinFrame; FinTitle.Size = UDim2.new(1,0,0,30); FinTitle.BackgroundTransparency = 1; FinTitle.Text = "TRAP SETTINGS"; FinTitle.TextColor3 = Colors.Accent; FinTitle.Font = Enum.Font.GothamBlack; FinTitle.TextSize = 12

local Fin2 = Btn(FinFrame, "2 Letters", UDim2.new(0,15,0,40), UDim2.new(1,-30,0,30))
local Fin3 = Btn(FinFrame, "3 Letters", UDim2.new(0,15,0,80), UDim2.new(1,-30,0,30))
local Fin4 = Btn(FinFrame, "4 Letters", UDim2.new(0,15,0,120), UDim2.new(1,-30,0,30))
local FinStatus = Instance.new("TextLabel"); FinStatus.Parent = FinFrame; FinStatus.Position = UDim2.new(0,0,0.85,0); FinStatus.Size = UDim2.new(1,0,0.1,0); FinStatus.BackgroundTransparency = 1; FinStatus.TextColor3 = Colors.SubText; FinStatus.Text = "Mode: OFF"; FinStatus.Font = Enum.Font.GothamBold; FinStatus.TextSize=10

local ListView = CreateFrame("ListView", UDim2.new(0,200,0,280), UDim2.new(0.5, 220, 0.5, 20), Screen); ListView.Visible = false
local ListScroll = Instance.new("ScrollingFrame"); ListScroll.Parent = ListView; ListScroll.Size = UDim2.new(1,-20,0.7,0); ListScroll.Position = UDim2.new(0,10,0,10); ListScroll.BackgroundTransparency = 1; ListScroll.CanvasSize = UDim2.new(0,0,0,0); ListScroll.ScrollBarThickness = 2
Instance.new("UIListLayout", ListScroll)
local CopyBtn= Btn(ListView, "Copy All", UDim2.new(0,15,0.85,0), UDim2.new(1,-30,0,30), Colors.Fg)

local function MakeDraggable(frame, trigger)
    local drag, start, startPos
    trigger.InputBegan:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseButton1 then drag=true; start=i.Position; startPos=frame.Position end end)
    trigger.InputChanged:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseMovement then dragInput=i end end)
    UserInputService.InputChanged:Connect(function(i) if i==dragInput and drag then local d=i.Position-start; frame.Position=UDim2.new(startPos.X.Scale, startPos.X.Offset+d.X, startPos.Y.Scale, startPos.Y.Offset+d.Y) end end)
    UserInputService.InputEnded:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseButton1 then drag=false end end)
end
MakeDraggable(Main, Top)
MakeDraggable(FinFrame, FinFrame) -- Drag anywhere on small frames
MakeDraggable(ListView, ListView)

--------------------------------------------------------------------------------
-- 5. TYPING ENGINE (UNCHANGED)
--------------------------------------------------------------------------------
local function TypeWord(word, skipCount)
    if not vim then return end 
    isTyping = true
    local isFlex = FlexB.Text:find("ON")
    
    local startDelay = GetRandomTime(TYPING_SETTINGS.StartSlowDelay)
    task.wait(startDelay) 

    local startIndex = (skipCount or 0) + 1

    for i = startIndex, #word do
        local char = word:sub(i,i):upper()
        local code = Enum.KeyCode[char] or (char == "-" and Enum.KeyCode.Minus)
        
        if isFlex and SafeRandom(1, 100) <= (FLEX_MODIFIERS.TypoChance * 100) and i > 2 and i < #word then
            local k = Enum.KeyCode[string.char(SafeRandom(65, 90))] 
            pcall(function() vim:SendKeyEvent(true,k,false,game); task.wait(0.02); vim:SendKeyEvent(false,k,false,game) end)
            task.wait(SafeRandom(20, 35)/100)
            pcall(function() vim:SendKeyEvent(true,Enum.KeyCode.Backspace,false,game); task.wait(0.02); vim:SendKeyEvent(false,Enum.KeyCode.Backspace,false,game) end)
            task.wait(SafeRandom(10, 25)/100)
        end

        if code then 
            pcall(function() 
                vim:SendKeyEvent(true,code,false,game)
                task.wait(0.02) 
                vim:SendKeyEvent(false,code,false,game) 
            end) 
        end
        
        local delay = GetRandomTime(TYPING_SETTINGS.BaseSpeed)
        if isFlex then 
            local totalHesitationChance = TYPING_SETTINGS.HesitationChance + FLEX_MODIFIERS.HesitationAdd
            local isBursting = (i > 3 and i < #word - 2) and (SafeRandom(1, 100) <= (FLEX_MODIFIERS.BurstChance * 100))
            if isBursting then delay = FLEX_MODIFIERS.BurstSpeed
            elseif SafeRandom(1, 100) <= (totalHesitationChance * 100) then delay = delay + GetRandomTime(TYPING_SETTINGS.HesitationDelay) end
        else
            if SafeRandom(1, 100) <= (TYPING_SETTINGS.HesitationChance * 100) then delay = delay + GetRandomTime(TYPING_SETTINGS.HesitationDelay) end
        end
        if isLockIn then delay = delay * LOCK_IN_MULTIPLIER end
        task.wait(math.max(0.015, delay))
    end
    task.wait(GetRandomTime(TYPING_SETTINGS.SubmitDelay))
    pcall(function() vim:SendKeyEvent(true,Enum.KeyCode.Return,false,game); task.wait(0.05); vim:SendKeyEvent(false,Enum.KeyCode.Return,false,game) end)
    isTyping = false
end

--------------------------------------------------------------------------------
-- 6. SEARCH ENGINE (UNCHANGED)
--------------------------------------------------------------------------------
local function DoSearch()
    if isTyping then return end
    local query = Sanitize(Input.Text):lower()
    if query == "" then return end
    WordStatus.Text = "Scanning..."
    
    local isFirstMode = FirstB.Text:find("ON")
    local isShortMode = ShortB.Text:find("ON")
    local isFlexMode  = FlexB.Text:find("ON")

    task.spawn(function()
        local found = nil
        if FinisherMode > 0 then
            local candidates = {}
            local yC = 0
            for _, v in ipairs(ALL_WORDS) do
                yC=yC+1; if yC%8000==0 then task.wait() end
                if #candidates > 200 then break end
                local w = Sanitize(v); local wLow = w:lower()
                if #w >= MIN_LETTER_COUNT and not CheckHist(w) and not IsBlacklisted(w) then
                    local match = false
                    if isFirstMode then if wLow:sub(1, #query) == query then match = true end
                    else if wLow:find(query, 1, true) then match = true end end
                    if match then table.insert(candidates, w) end
                end
            end
            ShuffleTable(candidates)
            if CurrentTargetSuffix and #CurrentTargetSuffix == FinisherMode then
                for _, w in ipairs(candidates) do
                    if w:lower():sub(-FinisherMode) == CurrentTargetSuffix then
                        found = w; TargetStreak = TargetStreak + 1; break 
                    end
                end
            end
            if not found then
                local bestTrapScore = 9999
                local newTarget = nil
                WordStatus.Text = "Switching Target..."
                for _, w in ipairs(candidates) do
                    if #w > FinisherMode then
                        local suffix = w:sub(-FinisherMode):lower()
                        local score = GetStartingCount(suffix)
                        if score < bestTrapScore then bestTrapScore = score; found = w; newTarget = suffix end
                    end
                    if bestTrapScore == 0 then break end
                end
                CurrentTargetSuffix = newTarget; TargetStreak = 1
            end
            if not found and #candidates > 0 then found = candidates[1] end
        else
            local yieldCounter = 0
            local bestLen = isShortMode and 999 or 0
            for _, v in ipairs(ALL_WORDS) do
                yieldCounter = yieldCounter + 1; 
                if yieldCounter % 15000 == 0 then task.wait() end 
                local w = Sanitize(v); local wLow = w:lower()
                if #w >= MIN_LETTER_COUNT and not CheckHist(w) and not IsBlacklisted(w) then
                    local match = false
                    if isFirstMode then if wLow:sub(1, #query) == query then match = true end
                    else if wLow:find(query, 1, true) then match = true end end
                    if match then
                        if isShortMode then if #w < bestLen then bestLen = #w; found = w end
                        elseif isFlexMode then if #w > bestLen then bestLen = #w; found = w end
                        else found = w; break end
                    end
                end
            end
        end
        if found then
            lastFound = found
            local extraInfo = ""
            if FinisherMode > 0 and CurrentTargetSuffix then extraInfo = " [Lock: \"" .. CurrentTargetSuffix:upper() .. "\" x" .. TargetStreak .. "]" end
            WordStatus.Text = "Typing: " .. found .. extraInfo
            WordStatus.TextColor3 = (FinisherMode > 0) and Color3.fromRGB(255, 100, 255) or Colors.Accent
            AddHist(found)
            task.wait(0.1) 
            local skip = 0; if isFirstMode then skip = #query end
            TypeWord(found, skip)
        else
            WordStatus.Text = "No word found!"
            WordStatus.TextColor3 = Colors.Red
        end
    end)
end

--------------------------------------------------------------------------------
-- 8. CONNECTIONS (MODIFIED COLORS ONLY)
--------------------------------------------------------------------------------
-- Re-mapped color changes to fit the new theme
FirstB.MouseButton1Click:Connect(function() local on=FirstB.Text:find("OFF"); FirstB.Text=on and "First: ON" or "First: OFF"; FirstB.TextColor3=on and Colors.Orange or Colors.Text end)
ShortB.MouseButton1Click:Connect(function() local on=ShortB.Text:find("OFF"); ShortB.Text=on and "Short: ON" or "Short: OFF"; ShortB.TextColor3=on and Colors.Green or Colors.Text; if on then FlexB.Text="Flex: OFF"; FlexB.TextColor3=Colors.Text end end)
FlexB.MouseButton1Click:Connect(function() local on=FlexB.Text:find("OFF"); FlexB.Text=on and "Flex: ON" or "Flex: OFF"; FlexB.TextColor3=on and Colors.Green or Colors.Text; if on then ShortB.Text="Short: OFF"; ShortB.TextColor3=Colors.Text end end)
LockB.MouseButton1Click:Connect(function() isLockIn=not isLockIn; LockB.Text=isLockIn and "Lock: ON" or "Lock: OFF"; LockB.TextColor3=isLockIn and Colors.Accent or Colors.Text end)

FinMenuB.MouseButton1Click:Connect(function() FinFrame.Visible = not FinFrame.Visible end)
local function SetFin(mode) FinisherMode = mode; CurrentTargetSuffix = nil; TargetStreak = 0; Fin2.TextColor3 = (mode==2) and Colors.Accent or Colors.Text; Fin3.TextColor3 = (mode==3) and Colors.Accent or Colors.Text; Fin4.TextColor3 = (mode==4) and Colors.Accent or Colors.Text; FinStatus.Text = (mode==0) and "Mode: OFF" or ("Mode: Trap " .. mode .. " Letters") end
Fin2.MouseButton1Click:Connect(function() SetFin(FinisherMode==2 and 0 or 2) end)
Fin3.MouseButton1Click:Connect(function() SetFin(FinisherMode==3 and 0 or 3) end)
Fin4.MouseButton1Click:Connect(function() SetFin(FinisherMode==4 and 0 or 4) end)

SaveB.MouseButton1Click:Connect(function() if lastFound=="" then return end; SESSION_BLACKLIST[lastFound:lower()]=true; table.insert(SAVED_LIST_UI, lastFound); local l=Instance.new("TextLabel"); l.Parent=ListScroll; l.Size=UDim2.new(1,0,0,20); l.BackgroundTransparency=1; l.TextColor3=Colors.SubText; l.TextSize=10; l.Text=lastFound; l.Font=Enum.Font.Gotham; ListScroll.CanvasSize=UDim2.new(0,0,0,#SAVED_LIST_UI*20); WordStatus.Text="Blacklisted: "..lastFound end)
LL_Btn.MouseButton1Click:Connect(function() LL_Enabled=not LL_Enabled; if LL_Enabled and next(LL_Table)==nil then WordStatus.Text="DL Blacklist..."; FetchBlacklist(LL_BLACKLIST_URL, LL_Table) end; LL_Btn.TextColor3=LL_Enabled and Colors.Orange or Colors.Text; LL_Btn.Text=LL_Enabled and "LL BL: ON" or "Last Letter BL" end)
WB_Btn.MouseButton1Click:Connect(function() WB_Enabled=not WB_Enabled; if WB_Enabled and next(WB_Table)==nil then WordStatus.Text="DL Blacklist..."; FetchBlacklist(WB_BLACKLIST_URL, WB_Table) end; WB_Btn.TextColor3=WB_Enabled and Colors.Red or Colors.Text; WB_Btn.Text=WB_Enabled and "WB BL: ON" or "Word Bomb BL" end)
ListB.MouseButton1Click:Connect(function() ListView.Visible = not ListView.Visible end)
CopyBtn.MouseButton1Click:Connect(function() if setclipboard then setclipboard(table.concat(SAVED_LIST_UI, ", ")); CopyBtn.Text="Copied!" task.wait(1) CopyBtn.Text="Copy All" end end)
ResetB.MouseButton1Click:Connect(function() GlobalEnv._UPB_History={}; WordStatus.Text="History Cleared" end)

RunBtn.MouseButton1Click:Connect(DoSearch)
Input.FocusLost:Connect(function(e) if e then DoSearch() end end)

task.spawn(function()
    local count = 0
    for _, url in ipairs(DictionaryURLs) do
        local s, content = pcall(function() return game:HttpGet(url) end)
        if s then for line in content:gmatch("[^\r\n]+") do table.insert(ALL_WORDS, line) count=count+1 end end
    end
    WordStatus.Text = "Loaded " .. count .. " Words"
end)
